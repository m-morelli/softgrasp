<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="http://www.petercorke.com/RVC/common/toolboxhelp.css">
    <title>M-File Help: SerialLink</title>
  </head>
  <body>
  <table border="0" cellspacing="0" width="100%">
    <tr class="subheader">
      <td class="headertitle">M-File Help: SerialLink</td>
      <td class="subheader-left"><a href="matlab:open SerialLink">View code for SerialLink</a></td>
    </tr>
  </table>
<h1>SerialLink</h1><p><span class="helptopic">Serial-link robot class</span></p><strong>r</strong> = <span style="color:red>SerialLink</span>(<strong>links</strong>, <strong>options</strong>) is a serial-link robot object from a
vector of Link objects.

<strong>r</strong> = <span style="color:red>SerialLink</span>(<strong>dh</strong>, <strong>options</strong>) is a serial-link robot object from a table
(matrix) of Denavit-Hartenberg parameters.  The columns of the matrix are
theta, d, alpha, a.  An optional fifth column sigma indicate
revolute (sigma=0, default) or prismatic (sigma=1).

<h2>Options</h2>
<table class="list">
  <tr><td style="white-space: nowrap;" class="col1">'name',  name</td> <td>set robot name property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'comment',  comment</td> <td>set robot comment property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'manufacturer',  manuf</td> <td>set robot manufacturer property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'base',  base</td> <td>set base transformation matrix property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'tool',  tool</td> <td>set tool transformation matrix property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'gravity',  g</td> <td>set gravity vector property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'plotopt',  po</td> <td>set plotting options property</td></tr>
</table>
<h2>Methods</h2>
<table class="list">
  <tr><td style="white-space: nowrap;" class="col1"> plot</td> <td>display graphical representation of robot</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> teach</td> <td>drive the graphical robot</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> fkine</td> <td>return forward kinematics</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> ikine6s</td> <td>return inverse kinematics for 6-axis spherical wrist robot</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> ikine</td> <td>return inverse kinematics using iterative method</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> jacob0</td> <td>return Jacobian matrix in world frame</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> jacobn</td> <td>return Jacobian matrix in tool frame</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> jtraj</td> <td>return a joint space trajectory</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> dyn</td> <td>show dynamic properties of links</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> isspherical</td> <td>true if robot has spherical wrist</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> islimit</td> <td>true if robot has spherical wrist</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> payload</td> <td>add a payload in end-effector frame</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> coriolis</td> <td>return Coriolis joint force</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> gravload</td> <td>return gravity joint force</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> inertia</td> <td>return joint inertia matrix</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> accel</td> <td>return joint acceleration</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> fdyn</td> <td>return joint motion</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> rne</td> <td>return joint force</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> perturb</td> <td>return SerialLink object with perturbed parameters</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> showlink</td> <td>return SerialLink object with perturbed parameters</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> friction</td> <td>return SerialLink object with perturbed parameters</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> maniplty</td> <td>return SerialLink object with perturbed parameters</td></tr>
</table>
<h2>Properties (read/write)</h2>
<table class="list">
  <tr><td style="white-space: nowrap;" class="col1"> links</td> <td>vector of Link objects</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> gravity</td> <td>direction of gravity [gx gy gz]</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> base</td> <td>pose of robot's base 4x4 homog xform</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> tool</td> <td>robot's tool transform, T6 to tool tip: 4x4 homog xform</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> qlim</td> <td>joint limits, [qlower qupper] nx2</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> offset</td> <td>kinematic joint coordinate offsets nx1</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> name</td> <td>name of robot, used for graphical display</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> manuf</td> <td>annotation, manufacturer's name</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> comment</td> <td>annotation, general comment</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> plotopt</td> <td>options for plot(robot), cell array</td></tr>
</table>
<h2>Object properties (read only)</h2>
<table class="list">
  <tr><td style="white-space: nowrap;" class="col1"> n </td> <td>number of joints</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> config</td> <td>joint configuration string, eg. 'RRRRRR'</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> mdh</td> <td>kinematic convention boolean (0=DH, 1=MDH)</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> islimit</td> <td>joint limit boolean vector</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> q </td> <td>joint angles from last plot operation</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> handle</td> <td>graphics handles in object</td></tr>
</table>
<h2>Note</h2>
<ul>
  <li>SerialLink is a reference object.</li>
  <li>SerialLink objects can be used in vectors and arrays</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc Link">Link</a>, <a href="matlab:doc DHFactor">DHFactor</a></p>
<hr>
<a name="SerialLink"><h1>SerialLink.SerialLink</h1></a>
<p><span class="helptopic">Create a SerialLink robot object</span></p><strong>R</strong> = <span style="color:red>SerialLink</span>(<strong>options</strong>) is a null robot object with no links.

<strong>R</strong> = <span style="color:red>SerialLink</span>(<strong>R1</strong>, <strong>options</strong>) is a deep copy of the robot object <strong>R1</strong>,
with all the same properties.

<strong>R</strong> = <span style="color:red>SerialLink</span>(<strong>dh</strong>, <strong>options</strong>) is a robot object with kinematics defined
by the matrix <strong>dh</strong> which has one row per joint and each row is
[theta d a alpha] and joints are assumed revolute.

<strong>R</strong> = <span style="color:red>SerialLink</span>(<strong>links</strong>, <strong>options</strong>) is a robot object defined by a vector
of Link objects.

<h2>Options</h2>
<table class="list">
  <tr><td style="white-space: nowrap;" class="col1">'name',  name</td> <td>set robot name property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'comment',  comment</td> <td>set robot comment property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'manufacturer',  manuf</td> <td>set robot manufacturer property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'base',  base</td> <td>set base transformation matrix property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'tool',  tool</td> <td>set tool transformation matrix property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'gravity',  g</td> <td>set gravity vector property</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'plotopt',  po</td> <td>set plotting options property</td></tr>
</table>
Robot objects can be concatenated by:

<pre style="width: 90%%;" class="examples">
R&nbsp;=&nbsp;R1&nbsp;*&nbsp;R2;
R&nbsp;=&nbsp;SerialLink([R1&nbsp;R2]);
</pre>
which is equivalent to R2 mounted on the end of <strong>R1</strong>.  Note that tool transform of <strong>R1</strong>
and the base transform of R2 are lost, constant transforms cannot be represented in
Denavit-Hartenberg notation.

<h2>Note</h2>
<ul>
  <li>SerialLink is a reference object, a subclass of Handle object.</li>
  <li>SerialLink objects can be used in vectors and arrays</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc Link">Link</a>, <a href="matlab:doc SerialLink.plot">SerialLink.plot</a></p>
<hr>
<a name="accel"><h1>SerialLink.accel</h1></a>
<p><span class="helptopic">Manipulator forward dynamics</span></p><strong>qdd</strong> = R.<span style="color:red>accel</span>(<strong>q</strong>, <strong>qd</strong>, <strong>torque</strong>) is a vector of joint accelerations that result
from applying the actuator force/torque to the manipulator robot in state <strong>q</strong> and <strong>qd</strong>.
If <strong>q</strong>, <strong>qd</strong>, <strong>torque</strong> are matrices with M rows, then <strong>qdd</strong> is a matrix with M rows
of acceleration corresponding to the equivalent rows of <strong>q</strong>, <strong>qd</strong>, <strong>torque</strong>.

<strong>qdd</strong> = R.<span style="color:red>ACCEL</span>(<strong>x</strong>) as above but <strong>x</strong>=[<strong>q</strong>,<strong>qd</strong>,<strong>torque</strong>].

<h2>Note</h2>
<ul>
  <li>Uses the method 1 of Walker and Orin to compute the forward dynamics.</li>
  <li>This form is useful for simulation of manipulator dynamics, in
conjunction with a numerical integration function.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.rne">SerialLink.rne</a>, <a href="matlab:doc SerialLink">SerialLink</a>, <a href="matlab:doc ode45">ode45</a></p>
<hr>
<a name="char"><h1>SerialLink.char</h1></a>
<p><span class="helptopic">String representation of parametesrs</span></p><strong>s</strong> = R.<span style="color:red>char</span>() is a string representation of the robot parameters.

<hr>
<a name="cinertia"><h1>SerialLink.cinertia</h1></a>
<p><span class="helptopic">Cartesian inertia matrix</span></p><strong>m</strong> = R.<span style="color:red>cinertia</span>(<strong>q</strong>) is the NxN Cartesian (operational space) inertia matrix which relates
Cartesian force/torque to Cartesian acceleration at the joint configuration <strong>q</strong>, and N
is the number of robot joints.

<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.inertia">SerialLink.inertia</a>, <a href="matlab:doc SerialLink.rne">SerialLink.rne</a></p>
<hr>
<a name="copy"><h1>SerialLink.copy</h1></a>
<p><span class="helptopic">Clone a robot object</span></p><strong>r2</strong> = R.<span style="color:red>copy</span>() is a deepcopy of the object R.

<hr>
<a name="coriolis"><h1>SerialLink.coriolis</h1></a>
<p><span class="helptopic">Coriolis matrix</span></p><strong>C</strong> = R.<span style="color:red>CORIOLIS</span>(<strong>q</strong>, <strong>qd</strong>) is the NxN Coriolis/centripetal matrix for
the robot in configuration <strong>q</strong> and velocity <strong>qd</strong>, where N is the number of
joints.  The product <strong>C</strong>*<strong>qd</strong> is the vector of joint force/torque due to velocity
coupling.  The diagonal elements are due to centripetal effects and the
off-diagonal elements are due to Coriolis effects.  This matrix is also
known as the velocity coupling matrix, since gives the disturbance forces
on all joints due to velocity of any joint.

If <strong>q</strong> and <strong>qd</strong> are row vectors, the result is a row-vector of joint torques.
If <strong>q</strong> and <strong>qd</strong> are matrices, each row is interpretted as a joint state
vector, and the result is a matrix each row being the  corresponding joint
torques.

<h2>Notes</h2>
<ul>
  <li>joint friction is also a joint force proportional to velocity but it is
eliminated in the computation of this value.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.rne">SerialLink.rne</a></p>
<hr>
<a name="display"><h1>SerialLink.display</h1></a>
<p><span class="helptopic">Display parameters</span></p>R.<span style="color:red>display</span>() displays the robot parameters in human-readable form.

<h2>Notes</h2>
<ul>
  <li>this method is invoked implicitly at the command line when the result
of an expression is a SerialLink object and the command has no trailing
semicolon.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.char">SerialLink.char</a>, <a href="matlab:doc SerialLink.dyn">SerialLink.dyn</a></p>
<hr>
<a name="dyn"><h1>SerialLink.dyn</h1></a>
<p><span class="helptopic">Display inertial properties</span></p>R.<span style="color:red>dyn</span>() displays the inertial properties of the <span style="color:red>SerialLink</span> object in a multi-line
format.  The properties shown are mass, centre of mass, inertia, gear ratio,
motor inertia and motor friction.

<h2>See also</h2>
<p>
<a href="matlab:doc Link.dyn">Link.dyn</a></p>
<hr>
<a name="fdyn"><h1>SerialLink.fdyn</h1></a>
<p><span class="helptopic">Integrate forward dynamics</span></p>[<strong>T</strong>,<strong>q</strong>,<strong>qd</strong>] = R.<span style="color:red>fdyn</span>(<strong>T1</strong>, <strong>torqfun</strong>) integrates the dynamics of the robot over
the time  interval 0 to <strong>T</strong> and returns vectors of time TI, joint position <strong>q</strong>
and joint velocity <strong>qd</strong>.  The initial joint position and velocity are zero.
The torque applied to the joints is computed by the user function <strong>torqfun</strong>:

[<strong>ti</strong>,<strong>q</strong>,<strong>qd</strong>] = R.<span style="color:red>fdyn</span>(<strong>T</strong>, <strong>torqfun</strong>, <strong>q0</strong>, <strong>qd0</strong>) as above but allows the initial
joint position and velocity to be specified.

The control torque is computed by a user defined function

TAU = <strong>torqfun</strong>(<strong>T</strong>, <strong>q</strong>, <strong>qd</strong>, ARG1, ARG2, ...)

where <strong>q</strong> and <strong>qd</strong> are the manipulator joint coordinate and velocity state
respectively], and <strong>T</strong> is the current time.

[<strong>T</strong>,<strong>q</strong>,<strong>qd</strong>] = R.<span style="color:red>fdyn</span>(<strong>T1</strong>, <strong>torqfun</strong>, <strong>q0</strong>, <strong>qd0</strong>, ARG1, ARG2, ...) allows optional
arguments to be passed through to the user function.

<h2>Note</h2>
<ul>
  <li>This function performs poorly with non-linear joint friction, such as
Coulomb friction.  The R.nofriction() method can be used to set this
friction to zero.</li>
  <li>If TORQFUN is not specified, or is given as 0 or [],  then zero torque
is applied to the manipulator joints.</li>
  <li>The builtin integration function ode45() is used.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.accel">SerialLink.accel</a>, <a href="matlab:doc SerialLink.nofriction">SerialLink.nofriction</a>, <a href="matlab:doc SerialLink.RNE">SerialLink.RNE</a>, <a href="matlab:doc ode45">ode45</a></p>
<hr>
<a name="fkine"><h1>SerialLink.fkine</h1></a>
<p><span class="helptopic">Forward kinematics</span></p><strong>T</strong> = R.<span style="color:red>fkine</span>(<strong>q</strong>) is the pose of the robot end-effector as a homogeneous
transformation for the joint configuration <strong>q</strong>.  For an N-axis manipulator
<strong>q</strong> is an N-vector.

If <strong>q</strong> is a matrix, the M rows are interpretted as the generalized
joint coordinates for a sequence of points along a trajectory.  <strong>q</strong>(i,j) is
the j'th joint parameter for the i'th trajectory point.  In this case
it returns a 4x4xM matrix where the last subscript is the index
along the path.

<h2>Note</h2>
<ul>
  <li>The robot's base or tool transform, if present, are incorporated into the
result.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.ikine">SerialLink.ikine</a>, <a href="matlab:doc SerialLink.ikine6s">SerialLink.ikine6s</a></p>
<hr>
<a name="friction"><h1>SerialLink.friction</h1></a>
<p><span class="helptopic">Friction force</span></p><strong>tau</strong> = R.<span style="color:red>friction</span>(<strong>qd</strong>) is the vector of joint <span style="color:red>friction</span> forces/torques for the
robot moving with joint velocities <strong>qd</strong>.

The <span style="color:red>friction</span> model includes viscous <span style="color:red>friction</span> (linear with velocity)
and Coulomb <span style="color:red>friction</span> (proportional to sign(<strong>qd</strong>)).

<h2>See also</h2>
<p>
<a href="matlab:doc Link.friction">Link.friction</a></p>
<hr>
<a name="gravload"><h1>SerialLink.gravload</h1></a>
<p><span class="helptopic">Gravity loading</span></p><strong>taug</strong> = R.<span style="color:red>gravload</span>(<strong>q</strong>) is the joint gravity loading for the robot in the
joint configuration <strong>q</strong>.  Gravitational acceleration is a property of the
robot object.

If <strong>q</strong> is a row vector, the result is a row vector of joint torques.  If
<strong>q</strong> is a matrix, each row is interpreted as a joint configuration vector,
and the result is a matrix each row being the corresponding joint torques.

<strong>taug</strong> = R.<span style="color:red>gravload</span>(<strong>q</strong>, <strong>grav</strong>) is as above but the gravitational
acceleration vector <strong>grav</strong> is given explicitly.

<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.rne">SerialLink.rne</a>, <a href="matlab:doc SerialLink.itorque">SerialLink.itorque</a>, <a href="matlab:doc SerialLink.coriolis">SerialLink.coriolis</a></p>
<hr>
<a name="ikine"><h1>SerialLink.ikine</h1></a>
<p><span class="helptopic">Inverse manipulator kinematics</span></p><strong>q</strong> = R.<span style="color:red>ikine</span>(<strong>T</strong>) is the joint coordinates corresponding to the robot
end-effector pose <strong>T</strong> which is a homogenenous transform.

<strong>q</strong> = R.<span style="color:red>ikine</span>(<strong>T</strong>, <strong>q0</strong>) specifies the initial estimate of the joint
coordinates.

<strong>q</strong> = R.<span style="color:red>ikine</span>(<strong>T</strong>, <strong>q0</strong>, <strong>m</strong>) specifies the initial estimate of the joint
coordinates and a mask matrix.  For the case where the manipulator
has fewer than 6 DOF the solution space has more dimensions than can
be spanned by the manipulator joint coordinates.  In this case
the mask matrix <strong>m</strong> specifies the Cartesian DOF (in the wrist coordinate
frame) that will be ignored in reaching a solution.  The mask matrix
has six elements that correspond to translation in X, Y and Z, and rotation
about X, Y and Z respectively.  The value should be 0 (for ignore) or 1.
The number of non-zero elements should equal the number of manipulator DOF.

For example when using a 5 DOF manipulator rotation about the wrist z-axis
might be unimportant in which case  <strong>m</strong> = [1 1 1 1 1 0].

In all cases if <strong>T</strong> is 4x4xM it is taken as a homogeneous transform sequence
and R.<span style="color:red>ikine</span>() returns the joint coordinates corresponding to each of the
transforms in the sequence.  <strong>q</strong> is MxN where N is the number of robot joints.
The initial estimate of <strong>q</strong> for each time step is taken as the solution
from the previous time step.

<h2>Notes</h2>
<ul>
  <li>Solution is computed iteratively using the pseudo-inverse of the
manipulator Jacobian.</li>
  <li>The inverse kinematic solution is generally not unique, and
depends on the initial guess Q0 (defaults to 0).</li>
  <li>Such a solution is completely general, though much less efficient
than specific inverse kinematic solutions derived symbolically.</li>
  <li>This approach allows a solution to obtained at a singularity, but
the joint angles within the null space are arbitrarily assigned.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.fkine">SerialLink.fkine</a>, <a href="matlab:doc tr2delta">tr2delta</a>, <a href="matlab:doc SerialLink.jacob0">SerialLink.jacob0</a>, <a href="matlab:doc SerialLink.ikine6s">SerialLink.ikine6s</a></p>
<hr>
<a name="ikine6s"><h1>SerialLink.ikine6s</h1></a>
<p><span class="helptopic">Inverse kinematics for 6-axis robot with spherical wrist</span></p><strong>q</strong> = R.<span style="color:red>ikine6s</span>(<strong>T</strong>) is the joint coordinates corresponding to the robot
end-effector pose <strong>T</strong> represented by the homogenenous transform.  This
is a analytic solution for a 6-axis robot with a spherical wrist (such as
the Puma 560).

<strong>q</strong> = R.<span style="color:red>IKINE6S</span>(<strong>T</strong>, <strong>config</strong>) as above but specifies the configuration of the arm in
the form of a string containing one or more of the configuration codes:

<table class="list">
  <tr><td style="white-space: nowrap;" class="col1"> 'l'</td> <td>arm to the left (default)</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'r'</td> <td>arm to the right</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'u'</td> <td>elbow up (default)</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'd'</td> <td>elbow down</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'n'</td> <td>wrist not flipped (default)</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'f'</td> <td>wrist flipped (rotated by 180 deg)</td></tr>
</table>
<h2>Notes</h2>
<ul>
  <li>The inverse kinematic solution is generally not unique, and
depends on the configuration string.</li>
</ul>
<h2>Reference</h2>
Inverse kinematics for a PUMA 560 based on the equations by Paul and Zhang
From The International Journal of Robotics Research
Vol. 5, No. 2, Summer 1986, p. 32-44

<h2>Author</h2>
Robert Biro with Gary Von McMurray,
GTRI/ATRP/IIMB,
Georgia Institute of Technology
2/13/95

<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.FKINE">SerialLink.FKINE</a>, <a href="matlab:doc SerialLink.IKINE">SerialLink.IKINE</a></p>
<hr>
<a name="inertia"><h1>SerialLink.inertia</h1></a>
<p><span class="helptopic">Manipulator inertia matrix</span></p><strong>i</strong> = R.<span style="color:red>inertia</span>(<strong>q</strong>) is the NxN symmetric joint <span style="color:red>inertia</span> matrix which relates
joint torque to joint acceleration for the robot at joint configuration <strong>q</strong>.
The diagonal elements <strong>i</strong>(j,j) are the <span style="color:red>inertia</span> seen by joint actuator j.
The off-diagonal elements are coupling inertias that relate acceleration
on joint i to force/torque on joint j.

<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.RNE">SerialLink.RNE</a>, <a href="matlab:doc SerialLink.CINERTIA">SerialLink.CINERTIA</a>, <a href="matlab:doc SerialLink.ITORQUE">SerialLink.ITORQUE</a></p>
<hr>
<a name="islimit"><h1>SerialLink.islimit</h1></a>
<p><span class="helptopic">Joint limit test</span></p><strong>v</strong> = R.<span style="color:red>ISLIMIT</span>(<strong>q</strong>) is a vector of boolean values, one per joint,
false (0) if <strong>q</strong>(i) is within the joint limits, else true (1).

<hr>
<a name="isspherical"><h1>SerialLink.isspherical</h1></a>
<p><span class="helptopic">Test for spherical wrist</span></p>R.<span style="color:red>isspherical</span>() is true if the robot has a spherical wrist, that is, the
last 3 axes intersect at a point.

<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.ikine6s">SerialLink.ikine6s</a></p>
<hr>
<a name="itorque"><h1>SerialLink.itorque</h1></a>
<p><span class="helptopic">Inertia torque</span></p><strong>taui</strong> = R.<span style="color:red>itorque</span>(<strong>q</strong>, <strong>qdd</strong>) is the inertia force/torque N-vector at the specified
joint configuration <strong>q</strong> and acceleration <strong>qdd</strong>, that is, <strong>taui</strong> = INERTIA(<strong>q</strong>)*<strong>qdd</strong>.

If <strong>q</strong> and <strong>qdd</strong> are row vectors, the result is a row vector of joint torques.
If <strong>q</strong> and <strong>qdd</strong> are matrices, each row is interpretted as a joint state
vector, and the result is a matrix each row being the corresponding joint
torques.

<h2>Note</h2>
<ul>
  <li>If the robot model contains non-zero motor inertia then this will
included in the result.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.rne">SerialLink.rne</a>, <a href="matlab:doc SerialLink.inertia">SerialLink.inertia</a></p>
<hr>
<a name="jacob0"><h1>SerialLink.jacob0</h1></a>
<p><span class="helptopic">Jacobian in world coordinates</span></p><strong>j0</strong> = R.<span style="color:red>jacob0</span>(<strong>q</strong>, <strong>options</strong>) is a 6xN Jacobian matrix for the robot in pose <strong>q</strong>.
The manipulator Jacobian matrix maps joint velocity to end-effector spatial
velocity V = <strong>j0</strong>*QD expressed in the world-coordinate frame.

<h2>Options</h2>
<table class="list">
  <tr><td style="white-space: nowrap;" class="col1"> 'rpy'</td> <td>Compute analytical Jacobian with rotation rate in terms of
roll-pitch-yaw angles</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'eul'</td> <td>Compute analytical Jacobian with rotation rates in terms of
Euler angles</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'trans'</td> <td>Return translational submatrix of Jacobian</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'rot'</td> <td>Return rotational submatrix of Jacobian</td></tr>
</table>
<h2>Note</h2>
<ul>
  <li>the Jacobian is computed in the world frame and transformed to the end-effector frame.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.jacobn">SerialLink.jacobn</a>, <a href="matlab:doc deltatr">deltatr</a>, <a href="matlab:doc tr2delta">tr2delta</a></p>
<hr>
<a name="jacob_dot"><h1>SerialLink.jacob_dot</h1></a>
<p><span class="helptopic">Hessian in end-effector frame</span></p><strong>jdq</strong> = R.<span style="color:red>jacob_dot</span>(<strong>q</strong>, <strong>qd</strong>) is the product of the Hessian, derivative of the
Jacobian, and the joint rates.

<h2>Notes</h2>
<ul>
  <li>useful for operational space control</li>
  <li>not yet tested/debugged.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc : SerialLink.jacob0">: SerialLink.jacob0</a>, <a href="matlab:doc diff2tr">diff2tr</a>, <a href="matlab:doc tr2diff">tr2diff</a></p>
<hr>
<a name="jacobn"><h1>SerialLink.jacobn</h1></a>
<p><span class="helptopic">Jacobian in end-effector frame</span></p><strong>jn</strong> = R.<span style="color:red>jacobn</span>(<strong>q</strong>, <strong>options</strong>) is a 6xN Jacobian matrix for the robot in
pose <strong>q</strong>. The manipulator Jacobian matrix maps joint velocity to
end-effector spatial velocity V = J0*QD in the end-effector frame.

<h2>Options</h2>
<table class="list">
  <tr><td style="white-space: nowrap;" class="col1"> 'trans'</td> <td>Return translational submatrix of Jacobian</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'rot'</td> <td>Return rotational submatrix of Jacobian</td></tr>
</table>
<h2>Reference</h2>
Paul, Shimano, Mayer,
Differential Kinematic Control Equations for Simple Manipulators,
IEEE SMC 11(6) 1981,
pp. 456-460

<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.jacob0">SerialLink.jacob0</a>, <a href="matlab:doc delta2tr">delta2tr</a>, <a href="matlab:doc tr2delta">tr2delta</a></p>
<hr>
<a name="jtraj"><h1>SerialLink.jtraj</h1></a>
<p><span class="helptopic">Create joint space trajectory</span></p><strong>q</strong> = R.<span style="color:red>jtraj</span>(<strong>T0</strong>, <strong>tf</strong>, <strong>m</strong>) is a joint space trajectory where the joint
coordinates reflect motion from end-effector pose <strong>T0</strong> to <strong>tf</strong> in <strong>m</strong> steps  with
default zero boundary conditions for velocity and acceleration.
The trajectory <strong>q</strong> is an MxN matrix, with one row per time step, and
one column per joint, where N is the number of robot joints.

<h2>Note</h2>
<ul>
  <li>requires solution of inverse kinematics. R.ikine6s() is used if
appropriate, else R.ikine().  Additional trailing arguments to R.jtraj()
are passed as trailing arugments to the these functions.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc jtraj">jtraj</a>, <a href="matlab:doc SerialLink.ikine">SerialLink.ikine</a>, <a href="matlab:doc SerialLink.ikine6s">SerialLink.ikine6s</a></p>
<hr>
<a name="maniplty"><h1>SerialLink.maniplty</h1></a>
<p><span class="helptopic">Manipulability measure</span></p><strong>m</strong> = R.<span style="color:red>maniplty</span>(<strong>q</strong>, <strong>options</strong>) is the manipulability index measure for the robot
at the joint configuration <strong>q</strong>.  It indicates dexterity, how isotropic the
robot's motion is with respect to the 6 degrees of Cartesian motion.
The measure is low when the manipulator is close to a singularity.
If <strong>q</strong> is a matrix <strong>m</strong> is a column vector of  manipulability
indices for each pose specified by a row of <strong>q</strong>.

Two measures can be selected:

<ul>
  <li>Yoshikawa's manipulability measure is based on the shape of the velocity
ellipsoid and depends only on kinematic parameters.</li>
  <li>Asada's manipulability measure is based on the shape of the acceleration
ellipsoid which in turn is a function of the Cartesian inertia matrix and
the dynamic parameters.  The scalar measure computed here is the ratio of
the smallest/largest ellipsoid axis.  Ideally the ellipsoid would be
spherical, giving a ratio of 1, but in practice will be less than 1.</li>
</ul>
<h2>Options</h2>
<table class="list">
  <tr><td style="white-space: nowrap;" class="col1"> 'T'</td> <td>compute manipulability for just transational motion</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'R'</td> <td>compute manipulability for just rotational motion</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'yoshikawa'</td> <td>use Asada algorithm (default)</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'asada'</td> <td>use Asada algorithm</td></tr>
</table>
<h2>Notes</h2>
<ul>
  <li>by default the measure includes rotational and translational dexterity, but
this involves adding different units.  It can be more useful to look at the
translational and rotational manipulability separately.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.inertia">SerialLink.inertia</a>, <a href="matlab:doc SerialLink.jacob0">SerialLink.jacob0</a></p>
<hr>
<a name="mtimes"><h1>SerialLink.mtimes</h1></a>
<p><span class="helptopic">Join robots</span></p>R = R1 * R2 is a robot object that is equivalent to mounting robot R2
on the end of robot R1.

<hr>
<a name="nofriction"><h1>SerialLink.nofriction</h1></a>
<p><span class="helptopic">Remove friction</span></p><strong>rnf</strong> = R.<span style="color:red>nofriction</span>() is a robot object with the same parameters as R but
with non-linear (Couolmb) friction coefficients set to zero.

<strong>rnf</strong> = R.<span style="color:red>nofriction</span>('all') as above but all friction coefficients set to zero.

Notes:

<ul>
  <li>Non-linear (Coulomb) friction can cause numerical problems when integrating
the equations of motion (R.fdyn).</li>
  <li>The resulting robot object has its name string modified by prepending 'NF/'.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.fdyn">SerialLink.fdyn</a>, <a href="matlab:doc Link.nofriction">Link.nofriction</a></p>
<hr>
<a name="payload"><h1>SerialLink.payload</h1></a>
<p><span class="helptopic">Add payload to end of manipulator</span></p>R.<span style="color:red>payload</span>(<strong>m</strong>, <strong>p</strong>) adds a <span style="color:red>payload</span> with point mass <strong>m</strong> at position <strong>p</strong>
in the end-effector coordinate frame.

<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.ikine6s">SerialLink.ikine6s</a></p>
<hr>
<a name="perturb"><h1>SerialLink.perturb</h1></a>
<p><span class="helptopic">Perturb robot parameters</span></p><strong>rp</strong> = R.<span style="color:red>perturb</span>(<strong>p</strong>) is a new robot object in which the dynamic parameters (link
mass and inertia) have been perturbed.  The perturbation is multiplicative so
that values are multiplied by random numbers in the interval (1-<strong>p</strong>) to (1+<strong>p</strong>).
The name string of the perturbed robot is prefixed by '<strong>p</strong>/'.

Useful for investigating the robustness of various model-based control
schemes. For example to vary parameters in the range +/- 10 percent is:

<pre style="width: 90%%;" class="examples">
r2&nbsp;=&nbsp;p560.perturb(0.1);
</pre>
<hr>
<a name="plot"><h1>SerialLink.plot</h1></a>
<p><span class="helptopic">Graphical display and animation</span></p>R.<span style="color:red>plot</span>(<strong>q</strong>, <strong>options</strong>) displays a graphical animation of a robot based on
the kinematic model.  A stick figure polyline joins the origins of
the link coordinate frames. The robot is displayed at the joint angle <strong>q</strong>, or
if a matrix it is animated as the robot moves along the trajectory.

The graphical robot object holds a copy of the robot object and
the graphical element is tagged with the robot's name (.name property).
This state also holds the last joint configuration which can be retrieved,
see PLOT(robot) below.

<h2>Figure behaviour</h2>
If no robot of this name is currently displayed then a robot will
be drawn in the current figure.  If hold is enabled (hold on) then the
robot will be added to the current figure.

If the robot already exists then that graphical model will be found
and moved.

<h2>Multiple views of the same robot</h2>
If one or more plots of this robot already exist then these will all
be moved according to the argument <strong>q</strong>.  All robots in all windows with
the same name will be moved.

<h2>Multiple robots in the same figure</h2>
Multiple robots can be displayed in the same <span style="color:red>plot</span>, by using "hold on"
before calls to <span style="color:red>plot</span>(robot).

<h2>Graphical robot state</h2>
The configuration of the robot as displayed is stored in the <span style="color:red>SerialLink</span> object
and can be accessed by the read only object property R.q.

<h2>Graphical annotations and options</h2>
The robot is displayed as a basic stick figure robot with annotations
such as:

<ul>
  <li>shadow on the floor</li>
  <li>XYZ wrist axes and labels</li>
  <li>joint cylinders and axes</li>
</ul>
which are controlled by <strong>options</strong>.

The size of the annotations is determined using a simple heuristic from
the workspace dimensions.  This dimension can be changed by setting the
multiplicative scale factor using the 'mag' option.

<h2>Options</h2>
<table class="list">
  <tr><td style="white-space: nowrap;" class="col1">'workspace',  W</td> <td>size of robot 3D workspace, W = [xmn, xmx ymn ymx zmn zmx]</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'delay',  d</td> <td>delay betwen frames for animation (s)</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'cylinder',  C</td> <td>color for joint cylinders, C=[r g b]</td></tr>
  <tr><td style="white-space: nowrap;" class="col1">'mag',  scale</td> <td>annotation scale factor</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'perspective'|'ortho'</td> <td>type of camera view</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'raise'|'noraise'</td> <td>controls autoraise of current figure on plot</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'render'|'norender'</td> <td>controls shaded rendering after drawing</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'loop'|'noloop'</td> <td>controls endless loop mode</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'base'|'nobase'</td> <td>controls display of base 'pedestal'</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'wrist'|'nowrist'</td> <td>controls display of wrist</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'shadow'|'noshadow'</td> <td>controls display of shadow</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'name'|'noname'</td> <td>display the robot's name</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'xyz'|'noa'</td> <td>wrist axis label</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'jaxes'|'nojaxes'</td> <td>control display of joint axes</td></tr>
  <tr><td style="white-space: nowrap;" class="col1"> 'joints'|'nojoints'</td> <td>controls display of joints</td></tr>
</table>
The <strong>options</strong> come from 3 sources and are processed in order:

<ul>
  <li>Cell array of options returned by the function PLOTBOTOPT.</li>
  <li>Cell array of options given by the 'plotopt' option when creating the
SerialLink object.</li>
  <li>List of arguments in the command line.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc plotbotopt">plotbotopt</a>, <a href="matlab:doc SerialLink.fkine">SerialLink.fkine</a></p>
<hr>
<a name="rne"><h1>SerialLink.rne</h1></a>
<p><span class="helptopic">Inverse dynamics</span></p><strong>tau</strong> = R.<span style="color:red>rne</span>(<strong>q</strong>, <strong>qd</strong>, <strong>qdd</strong>) is the joint torque required for the robot R
to achieve the specified joint position <strong>q</strong>, velocity <strong>qd</strong> and acceleration <strong>qdd</strong>.

<strong>tau</strong> = R.<span style="color:red>rne</span>(<strong>q</strong>, <strong>qd</strong>, <strong>qdd</strong>, <strong>grav</strong>) as above but overriding the gravitational
acceleration vector in the robot object R.

<strong>tau</strong> = R.<span style="color:red>rne</span>(<strong>q</strong>, <strong>qd</strong>, <strong>qdd</strong>, <strong>grav</strong>, <strong>fext</strong>) as above but specifying a wrench
acting on the end of the manipulator which is a 6-vector [Fx Fy Fz Mx My Mz].

<strong>tau</strong> = R.<span style="color:red>rne</span>(<strong>x</strong>) as above where <strong>x</strong>=[<strong>q</strong>,<strong>qd</strong>,<strong>qdd</strong>].

<strong>tau</strong> = R.<span style="color:red>rne</span>(<strong>x</strong>, <strong>grav</strong>) as above but overriding the gravitational
acceleration vector in the robot object R.

<strong>tau</strong> = R.<span style="color:red>rne</span>(<strong>x</strong>, <strong>grav</strong>, <strong>fext</strong>) as above but specifying a wrench
acting on the end of the manipulator which is a 6-vector [Fx Fy Fz Mx My Mz].

If <strong>q</strong>,<strong>qd</strong> and <strong>qdd</strong>, or <strong>x</strong> are matrices with M rows representing a trajectory then
<strong>tau</strong> is an MxN matrix with rows corresponding to each trajectory state.

Notes:

<ul>
  <li>The torque computed also contains a contribution due to armature
inertia.</li>
  <li>RNE can be either an M-file or a MEX-file.  See the manual for details on
how to configure the MEX-file.  The M-file is a wrapper which calls either
RNE_DH or RNE_MDH depending on the kinematic conventions used by the robot
object.</li>
</ul>
<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.accel">SerialLink.accel</a>, <a href="matlab:doc SerialLink.gravload">SerialLink.gravload</a>, <a href="matlab:doc SerialLink.inertia">SerialLink.inertia</a></p>
<hr>
<hr>
<hr>
<a name="showlink"><h1>SerialLink.showlink</h1></a>
<p><span class="helptopic">Show parameters of all links</span></p>R.<span style="color:red>showlink</span>() shows details of all link parameters for the robot object,
including inertial parameters.

<h2>See also</h2>
<p>
<a href="matlab:doc Link.showlink">Link.showlink</a>, <a href="matlab:doc Link">Link</a></p>
<hr>
<a name="teach"><h1>SerialLink.teach</h1></a>
<p><span class="helptopic">Graphical teach pendant</span></p>R.<span style="color:red>teach</span>() drive a graphical robot by means of a graphical slider panel.
If no graphical robot exists one is created in a new window.  Otherwise
all current instanes of the graphical robots are driven.

R.<span style="color:red>teach</span>(<strong>q</strong>) specifies the initial joint angle, otherwise it is taken from
one of the existing graphical robots.

<h2>See also</h2>
<p>
<a href="matlab:doc SerialLink.plot">SerialLink.plot</a></p>
<hr>

<table border="0" width="100%" cellpadding="0" cellspacing="0">
  <tr class="subheader" valign="top"><td>&nbsp;</td></tr></table>
<p class="copy">&copy; 1990-2011 Peter Corke.</p>
</body></html>